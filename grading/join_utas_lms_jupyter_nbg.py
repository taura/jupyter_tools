#!/usr/bin/env python

import argparse
import csv
import os
import sys
import shutil
import pandas as pd
import openpyxl

def load_worksheet(xlsx, sheet=0, header_row=None, start_row=None):
    """
    read an xlsx file (of utas, itc_lms, or jupyter)
    """
    wb = openpyxl.load_workbook(xlsx, data_only=True) # , read_only=True
    if isinstance(sheet, type(0)):
        ws = wb.worksheets[sheet]
    else:
        ws = wb[sheet]
    rows = list(ws.rows)
    if header_row is None:
        header = None
    else:
        header = [cell.value for cell in rows[header_row]]
    if start_row is None:
        if header_row is None:
            start_row = 0
        else:
            start_row = header_row + 1
    return header, rows[start_row:]

def make_xlsx_rows(rows):
    """
    make an excel from a list of rows
    """
    wb = openpyxl.Workbook()
    ws = wb.active
    for row in rows:
        ws.append(row)
    return ws.rows

def read_csv_xlsx_ods(a_file, ext=None):
    """
    read xlsx, ods, or csv and return a pandas data frame
    """
    if ext is None:
        if a_file.endswith(".csv"):
            ext = ".csv"
        elif a_file.endswith(".ods"):
            ext = ".ods"
        elif a_file.endswith(".xlsx"):
            ext = ".xlsx"
    if ext == ".csv":
        df = pd.read_csv(a_file, keep_default_na=False)
    elif ext == ".ods":
        df = pd.read_excel(a_file, keep_default_na=False, engine="odf")
    elif ext == ".xlsx":
        df = pd.read_excel(a_file, keep_default_na=False)
    else:
        assert(0), ("unknown extension for {}, consider giving ext= keyword arg".format(a_file))
    return df

def load_and_pivot(files, row_fields, col_fields, val_field):
    """
    load a bunch of csv/ods/xlsx files (normally of the same type,
    but not limited to one) generated by work.py export (and
    perhaps converted into respective types), concatenate all
    of them, and make a two dimensional table whose rows are
    all values that appear in columns specified in row_fields
    and whose columns are all values that appear in columns
    specified in col_fields. e.g., when files look like
    A B C D 
    a b c d
    e f g h
    i j k l
    row_fields = ["A"]
    col_fields = ["B"]
    val_field = "D"

      b f j
    a d 
    e   h
    i     l

    """
    data = {}
    all_row_keys = set()
    all_col_keys = set()
    for a_file in files:
        df = read_csv_xlsx_ods(a_file)
        for i, row in df.iterrows():
            row_keys = tuple([row[field] for field in row_fields])
            col_keys = tuple([row[field] for field in col_fields])
            val = row[val_field]
            all_row_keys.add(row_keys)
            all_col_keys.add(col_keys)
            assert((row_keys + col_keys) not in data)
            if row_keys + col_keys == ("u24209", 'os2024_exam', 'problem_3.sos', 'p-013'):
                print(row_keys, col_keys, val, row)
            data[row_keys + col_keys] = val
    rows = []
    all_row_keys = sorted(list(all_row_keys))
    all_col_keys = sorted(list(all_col_keys))
    for row_keys in all_row_keys:
        row = [row_keys[i] for i in range(len(row_fields))]
        for col_keys in all_col_keys:
            row.append(data.get(row_keys + col_keys, ""))
        rows.append(row)
    header = row_fields + ["-".join(col_keys) for col_keys in all_col_keys]
    return header, make_xlsx_rows(rows)

def check_dup(filename, rows, make_key):
    last_row = None
    last_key = None
    found = 0
    for row in rows:
        key = make_key(row)
        if key == last_key and key != "":
            print("WARN: duplicated key {} in {}".format(key, filename))
            print(last_key, row_val(last_row))
            print(key, row_val(row))
            found += 1
        last_key = key
        last_row = row
    return found

def merge_rows(file0, rows0, make_key0, file1, rows1, make_key1):
    rows0 = sorted(rows0, key=make_key0)
    rows1 = sorted(rows1, key=make_key1)
    if check_dup(file0, rows0, make_key0) > 0:
        return None
    if check_dup(file1, rows1, make_key1) > 0:
        return None
    n0 = len(rows0)
    n1 = len(rows1)
    ei = (None,) * len(rows0[0]) if n0 > 0 else ()
    ej = (None,) * len(rows1[0]) if n1 > 0 else ()
    merged_rows = []
    i = 0
    j = 0
    while i < n0 or j < n1:
        if j >= n1:
            # rows1 have ran out. fill rows1's columns with None
            ri = rows0[i]
            merged_rows.append(ri + ej)
            i += 1
        elif i >= n0:
            # rows0 have ran out. fill rows0's columns with None
            rj = rows1[j]
            merged_rows.append(ei + rj)
            j += 1
        else:
            ri = rows0[i]
            rj = rows1[j]
            ki = make_key0(ri)
            kj = make_key1(rj)
            if ki < kj:
                merged_rows.append(ri + ej)
                i += 1
            elif ki > kj:
                merged_rows.append(ei + rj)
                j += 1
            else:
                assert(ki == kj)
                merged_rows.append(ri + rj)
                i += 1
                j += 1
    return merged_rows

def cell_val(cell):
    if cell is None:
        return ""
    elif cell.value is None:
        return ""
    else:
        return cell.value

def row_val(row):
    return [cell_val(cell) for cell in row]

def make_joined_wb(utas_file, utas_header, utas_rows,
                   lms_file, lms_header, lms_rows,
                   jupyter_file, jupyter_header, jupyter_rows,
                   nbg_file, nbg_header, nbg_rows):
    #print("utas_header = {}".format(utas_header))
    utas_id_col = utas_header.index("学生証番号")
    def utas_key(row):
        return cell_val(row[utas_id_col])
    #print("lms_header = {}".format(lms_header))
    lms_id_col = lms_header.index("学生証番号")
    def lms_key(row):
        return cell_val(row[lms_id_col]).replace("-", "")
    #print("jupyter_header = {}".format(jupyter_header))
    # student id in juptyer.xlsx
    jupyter_id_col = jupyter_header.index("id")
    # symbolic user name in juptyer.xlsx (u22000, u22001, ...)
    jupyter_user_col = jupyter_header.index("user")
    # jupyter_user_col = jupyter_header.index("uid")
    def jupyter_id_key(row):
        oval = cell_val(row[jupyter_id_col])
        if isinstance(oval, type(0)):
            val = str(oval)
        else:
            val = oval
        val = val.replace("-", "")
        assert(len(val) in [0, 7, 8]), oval
        if len(val) > 0:
            val = "0" * (8 - len(val)) + val
        return val
    # join UTAL and LMS with UTAS 学生証番号 = LMS 学生証番号
    utas_lms_rows = merge_rows(utas_file, utas_rows, utas_key,
                               lms_file, lms_rows, lms_key)
    if utas_lms_rows is None:
        return None, None
    utas_lms_n_cols = len(utas_lms_rows[0])
    # join UTAL+LMS and JUPYTER with UTAS/LMS 学生証番号 = JUPYTER id
    utas_lms_jupyter_rows = merge_rows(utas_file, utas_lms_rows, utas_key,
                                       jupyter_file, jupyter_rows, jupyter_id_key)
    if utas_lms_jupyter_rows is None:
        return None, None
    def jupyter_user_key(row):
        return cell_val(row[utas_lms_n_cols + jupyter_user_col])
    # join UTAL+LMS+JUPYTER and NBG with JUPYTER UID = NBG STUDENT ID
    #print("nbg_header = {}".format(nbg_header))
    nbg_student_id_col = nbg_header.index("student_id")
    def nbg_user_key(row):
        return cell_val(row[nbg_student_id_col])
    all_rows = merge_rows(jupyter_file, utas_lms_jupyter_rows, jupyter_user_key,
                          nbg_file, nbg_rows, nbg_user_key)
    if all_rows is None:
        return None, None
    all_header = utas_header + lms_header + jupyter_header + nbg_header
    return all_header, all_rows

def create_xlsx(header, rows, a_xlsx):
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.append(header)
    for row in rows:
        ws.append([cell.value if cell is not None else None for cell in row])
    wb.save(a_xlsx)
    n_rows = ws.max_row
    n_cols = ws.max_column
    print(f"{n_rows} x {n_cols} cells written to {a_xlsx}")
    return 1

def update_xlsx(header, rows, a_xlsx):
    wb = openpyxl.load_workbook(a_xlsx)
    ws = wb.active
    M = ws.max_row
    N = ws.max_column
    # number of rows + 1 (for the header) must match the number of lines in the file
    if len(rows) + 1 != M:
        print(f"the number of rows in data ({len(rows)})"
              f" does not match rows in the file ({M - 1})",
              file=sys.stderr)
        return 0                # NG
    # the leftmost column of the file is the sequential number not to be overwritten
    if len(header) > N:
        print(f"the number of columns in data ({len(header)}) exceeds columns in the file ({N})",
              file=sys.stderr)
        return 0                # NG
    # the first line in the file must match the header
    # col_map[i] is the column number in the file corresponding to the i-th column in header
    col_map = []
    jj = 1
    for j, h in enumerate(header):
        while jj <= N:
            v = ws.cell(row=1, column=jj).value
            if v == h:
                # print(f"{j}-th header ({h}) -> {jj}")
                break
            # print(f"skip {jj}-column ({v})")
            jj += 1
        if jj > N:
            print(f"could not find a column {h} in the header row of {a_xlsx}",
                  file=sys.stderr)
            return 0            # NG
        col_map.append(jj)
        jj += 1
    assert(len(col_map) == len(header)), (len(col_map), len(header))
    # we write rows -> cells[2:M,2:N] (indices are 1-origin)
    n_cells = len(rows) * len(header)
    n_updated = 0
    for i, row in enumerate(rows):
        assert(len(row) == len(header)), (len(row), len(header))
        for j, cell in enumerate(row):
            wscell = ws.cell(row=i + 2, column=col_map[j])
            v = None if cell is None else cell.value
            if wscell.value == v:
                # print(f"cell[{i},{j}] ({v}) does not change")
                pass
            elif wscell.value is None and v == "":
                pass
            else:
                # print(f"cell[{i},{j}] ({wscell.value}) <- {v} overwritten")
                n_updated += 1
                wscell.value = v
    wb.save(a_xlsx)
    print(f"{n_updated} cells of {a_xlsx} updated")
    return 1                    # OK

def make_backup_file_name(a_xlsx):
    b = f"{a_xlsx}~"
    if not os.path.exists(b):
        return b
    for i in range(10):
        b = f"{a_xlsx}~{i}~"
        if not os.path.exists(b):
            return b
    print(f"too many backup files for {a_xlsx}. perhaps you want to (re)move them",
          file=sys.stderr)
    return None
    
def create_or_update_xlsx(header, rows, a_xlsx, force_create, backup):
    if force_create or not os.path.exists(a_xlsx):
        return create_xlsx(header, rows, a_xlsx)
    else:
        if backup:
            b_xlsx = make_backup_file_name(a_xlsx)
            if b_xlsx is None:
                return 0        # NG
            shutil.copyfile(a_xlsx, b_xlsx)
        return update_xlsx(header, rows, a_xlsx)

def write_to_xlsx_or_csv(df, header, a, xlsx_or_csv):
    if xlsx_or_csv == "xlsx":
        t = f"tmp_{a}"
        shutil.copyfile(a, t)
        with pd.ExcelWriter(t, mode="a", if_sheet_exists="overlay",
                            engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name="Sheet1", header=header, index=False)
        os.replace(t, a)
    elif xlsx_or_csv == "csv":
        df.to_csv(a, header=header, index=False)
    else:
        assert(xlsx_or_csv in ["xlsx", "csv"]), xlsx_or_csv

    
def read_file(filename):
    with open(filename) as fp:
        return fp.read()

def common_prefix_length(str1, str2):
    min_length = min(len(str1), len(str2))
    for i in range(min_length):
        if str1[i] != str2[i]:
            return i
    return min_length

# find a directory in TOP that looks like the directory for ASSIGNMENT
# 
def find_assignment_dir(top, assignment):
    assignment_key = assignment.replace("/", "_")
    assignment_dirs = os.listdir(top)
    for d in assignment_dirs:
        if assignment_key.startswith(d):
            return d
    assert(0), (top, assignment)
    
def find_submission_text(directory, student_id, assignment):
    student_top = f"{directory}/{student_id}"
    assignment_dir = find_assignment_dir(student_top, assignment)
    return f"{student_top}/{assignment_dir}/{student_id}_submissionText.txt"
    
def read_submission_texts(header, rows, directory):
    submission_text_cols = {}
    for j, assignment in enumerate(header):
        if assignment is not None:
            # Assignment 0: Jupyter password|None|None|None|None|
            # 提出状況|評価|コメント|成果物ファイル名|最終更新日時
            submission_text_cols[j + 3] = assignment
    student_id_col = header.index("学生証番号")
    # 03220431_submissionText.txt
    for row in rows:
        student_id = row[student_id_col].value
        for j, assignment in submission_text_cols.items():
            val = row[j].value
            if "submissionText.txt" in val:
                sub_txt = find_submission_text(directory, student_id, assignment)
                row[j].value = read_file(sub_txt)
    return header, rows
    
def parse_args(argv):
    psr = argparse.ArgumentParser()
    psr.add_argument("--utas", metavar="UTAS_XLSX",
                     default="data/utas.xlsx",
                     help="UTAS Excel (UTAS -> 成績登録 -> select your lecture -> Excel出力 -> Excel (和文)); remove password by opening it with Windows Excel and File -> 情報 -> ブックの保護 -> パスワードによる暗号化")
    psr.add_argument("--lms", metavar="LMS_XLSX",
                     default="data/utol.xlsx",
                     help="LMS assignment Excel (UTOL -> 課題 -> 全履修者の提出物確認 -> zipダウンロード -> zip解凍 -> ExcelをWindowsのExcelで開く -> 情報 -> ブックの保護 -> パスワードによる暗号化 -> パスワードを空にして保存)")
    psr.add_argument("--lms-submission-files-dir", metavar="DIR",
                     default="data/utol",
                     help="Directory of submitted files (上記zipの解凍してできたフォルダ)")
    psr.add_argument("--jupyter", metavar="JUPYTER_XLSX",
                     default="data/jupyter.xlsx",
                     help="Jupyter Excel (Jupyter Googlesheet)")
    psr.add_argument("--grade", metavar="GRADE_CSV",
                     default="grade.csv",
                     help='grade.csv generated by work.py export')
    psr.add_argument("grades", nargs="*", metavar="GRADE_CSV/ODS/XLS(s)",
                     default=["grade.xlsx"],
                     help='grade.csv generated by work.py export or ods/xls converted from it')
    psr.add_argument("--out", metavar="UTAS_LMS_JUPYTER_NBGRADER_XLSX",
                     default="utas_lms_jupyter_nbgrader.xlsx",
                     help="Output Excel")
    psr.add_argument("--update", metavar="0/1", type=int, default=1,
                     help="if the output Excel file exists, update it rather than create it")
    psr.add_argument("--backup", metavar="0/1", type=int, default=1,
                     help="if the existing Excel file is updated, make a backup")
    args = psr.parse_args(argv[1:])
    return args

def main():
    args = parse_args(sys.argv)
    utas_header, utas_rows = load_worksheet(args.utas, header_row=3)
    lms_header, lms_rows = load_worksheet(args.lms,
                                          #sheet='課題全体提出状況',
                                          sheet=0,
                                          header_row=0,
                                          start_row=2)
    directory = args.lms_submission_files_dir
    lms_header, lms_rows = read_submission_texts(lms_header, lms_rows, directory)
    jupyter_header, jupyter_rows = load_worksheet(args.jupyter, header_row=0)
    nbg_header, nbg_rows = load_and_pivot(args.grades, ["student_id"], ["assignment_name", "notebook_name", "prob_name"], "manual_score")
    header, rows = make_joined_wb(args.utas, utas_header, utas_rows,
                                  args.lms, lms_header, lms_rows,
                                  args.jupyter, jupyter_header, jupyter_rows,
                                  str(args.grades), nbg_header, nbg_rows)
    if header is None:
        return None
    #save_xlsx(header, rows, args.out)
    ok = create_or_update_xlsx(header, rows, args.out, not args.update, args.backup)
    if ok:
        return 0
    else:
        return 1
    
sys.exit(main())



